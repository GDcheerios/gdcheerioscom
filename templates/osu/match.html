<html>
    <head>
        {% block head %}
        <title>Home</title>
        <link rel="stylesheet" href="/static/style.css">
        <link rel="stylesheet" href="/static/osu-style.css">
        <style>
            @keyframes fadeSlideIn {
                from {
                    opacity: 0;
                    transform: translateY(-10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .player {
                opacity: 0;
                transform: translateY(-10px);
                animation: fadeSlideIn 0.4s ease-out forwards;
                transition: transform 0.35s ease, opacity 0.35s ease;
            }

            /* --- NEW: score bump + row move animations --- */
            @keyframes scoreBumpUp {
                0%   { transform: scale(1);   filter: none; }
                35%  { transform: scale(1.08); filter: drop-shadow(0 0 10px rgba(60, 255, 160, 0.55)); }
                100% { transform: scale(1);   filter: none; }
            }
            @keyframes scoreBumpDown {
                0%   { transform: scale(1);   filter: none; }
                35%  { transform: scale(0.98); filter: drop-shadow(0 0 10px rgba(255, 90, 90, 0.45)); }
                100% { transform: scale(1);   filter: none; }
            }
            .player-score-value.score-up {
                animation: scoreBumpUp 520ms ease-out;
            }
            .player-score-value.score-down {
                animation: scoreBumpDown 520ms ease-out;
            }

            /* Smooth “move up/down” (FLIP) */
            .player-row {
                will-change: transform;
            }

            .match-actions {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin: 10px 0 18px 0;
            }

            .match-button {
                padding: 10px 14px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.18);
                color: white;
                cursor: pointer;
                font-weight: 600;
            }

            .match-button--end {
                background: rgba(255, 90, 90, 0.18);
            }

            .match-button--refresh {
                background: rgba(60, 255, 160, 0.18);
            }
        </style>
        {% endblock %}
    </head>
    <body>
        {% include 'navbar.html' %}
        {% block body %}
            <h1 style="text-align: center">{{ match.name }}</h1>

            {% if is_creator and not match.ended %}
                <div class="match-actions">
                    <button id="end-match-btn" class="match-button match-button--end" onclick="endMatch()" type="button">
                        End match
                    </button>
                    <button id="refresh-match-btn" class="match-button match-button--refresh" onclick="refreshMatch()" type="button">
                        Refresh match
                    </button>
                </div>
            {% endif %}

            <div class="match-layout">
                <!-- LEFT: players -->
                <div id="match-info" class="match-players-column">
                    <div id="loading-indicator">
                        <p>Loading match data...</p>
                    </div>
                </div>

                <!-- RIGHT: teams overview -->
                <div id="teams-overview" class="teams-overview">
                    <!-- filled by JS -->
                </div>
            </div>
            <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
            <script>
                const players = {{ players | tojson }};
                const currentOsuId = {{ current_osu_id|tojson }};  // may be null
                const matchId = {{ match.id | tojson }};
                const matchEnded = {{ match.ended | tojson }};

                console.log("[match] script loaded", {
                    matchId,
                    matchEnded,
                    currentOsuId,
                    playersCount: Array.isArray(players) ? players.length : null,
                });

                async function endMatch() {
                    if (matchEnded) return;

                    const ok = confirm("End this match now? This will lock in ending scores/playcounts.");
                    if (!ok) return;

                    const btn = document.getElementById("end-match-btn");
                    if (btn) {
                        btn.disabled = true;
                        btn.textContent = "Ending...";
                    }

                    try {
                        const res = await fetch(`/api/osu/end-match/${encodeURIComponent(String(matchId))}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        });

                        if (!res.ok) {
                            let msg = "Failed to end match.";
                            try {
                                const data = await res.json();
                                if (data && data.error) msg = data.error;
                            } catch (_) {}
                            throw new Error(msg);
                        }

                        window.location.reload();
                    } catch (e) {
                        alert(e?.message || "Failed to end match.");
                        if (btn) {
                            btn.disabled = false;
                            btn.textContent = "End match";
                        }
                    }
                }

                async function refreshMatch() {
                    try {
                        res = await fetch(`/api/osu/refresh-match/${encodeURIComponent(String(matchId))}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                        });
                    } catch (e) {
                        alert("Failed to refresh match data.");
                    }
                }

                function applyMatchRelativeScores(playersArr) {
                    console.log("[match] applyMatchRelativeScores() start");
                    for (const player of playersArr) {
                        if (matchEnded) {
                            player.score = (player.ending_score - player.starting_score);
                            player.playcount = player.ending_playcount - player.starting_playcount;
                        } else {
                            player.score = (player.score - player.starting_score);
                            player.playcount = player.playcount - player.starting_playcount;
                        }
                    }
                    console.log("[match] applyMatchRelativeScores() done");
                }

                applyMatchRelativeScores(players);

                // --- helpers for animations ---
                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }

                function animateNumber(el, from, to, durationMs = 650) {
                    if (!el) {
                        console.warn("[anim] animateNumber called with null el");
                        return;
                    }
                    const start = performance.now();
                    const safeFrom = Number.isFinite(from) ? from : 0;
                    const safeTo = Number.isFinite(to) ? to : 0;

                    console.log("[anim] animateNumber", {
                        target: el.dataset,
                        from: safeFrom,
                        to: safeTo,
                        durationMs
                    });

                    function tick(now) {
                        const t = Math.min(1, (now - start) / durationMs);
                        const v = Math.round(safeFrom + (safeTo - safeFrom) * easeOutCubic(t));
                        el.textContent = v.toLocaleString();

                        if (t < 1) requestAnimationFrame(tick);
                    }
                    requestAnimationFrame(tick);
                }

                function bumpScore(el, direction) {
                    if (!el) return;
                    el.classList.remove("score-up", "score-down");
                    void el.offsetWidth;
                    el.classList.add(direction > 0 ? "score-up" : "score-down");
                }

                function captureRowPositions() {
                    const map = new Map();
                    document.querySelectorAll("#match-info .player-row[data-player-id]").forEach(row => {
                        map.set(row.dataset.playerId, row.getBoundingClientRect());
                    });
                    console.log("[render] captured row positions:", map.size);
                    return map;
                }

                function animateRowReorder(prevRects) {
                    let moved = 0;
                    document.querySelectorAll("#match-info .player-row[data-player-id]").forEach(row => {
                        const id = row.dataset.playerId;
                        const prev = prevRects.get(id);
                        if (!prev) return;

                        const next = row.getBoundingClientRect();
                        const dy = prev.top - next.top;
                        if (Math.abs(dy) < 1) return;
                        moved++;

                        row.style.transition = "none";
                        row.style.transform = `translateY(${dy}px)`;
                        requestAnimationFrame(() => {
                            row.style.transition = "transform 420ms cubic-bezier(0.2, 0.9, 0.2, 1)";
                            row.style.transform = "translateY(0)";
                            setTimeout(() => {
                                row.style.transition = "";
                                row.style.transform = "";
                            }, 460);
                        });
                    });
                    console.log("[render] animateRowReorder moved rows:", moved);
                }

                async function refreshPlayer(player, buttonEl) {

                    buttonEl.disabled = true;
                    buttonEl.textContent = "Refreshing...";

                    try {
                        const response = await fetch(
                            `/api/osu/fetch-user/${encodeURIComponent(player.id)}`,
                            { method: "GET" }
                        );
                        if (!response.ok) {
                            throw new Error("Failed to refresh");
                        }
                        else {
                            setTimeout(() => {
                                buttonEl.disabled = false
                                buttonEl.textContent = "Refresh";
                            }, 5000);
                        }
                    } catch (e) {
                        console.error(e);
                        buttonEl.disabled = false;
                        buttonEl.textContent = "Refresh";
                        alert("Failed to refresh player data.");
                    }
                }

                function createPlayerRow(player, index) {
                    const row = document.createElement('div');
                    row.className = 'player-row';
                    row.dataset.playerId = String(player.id);

                    const rankText = document.createElement('div');
                    rankText.className = 'player-rank';
                    rankText.textContent = index + 1;

                    const card = document.createElement('div');
                    card.className = 'player';
                    card.style.animationDelay = `${index * 0.1}s`;

                    const bg = document.createElement('div');
                    bg.className = 'player-bg';
                    if (player.background) {
                        bg.style.backgroundImage = `url('${player.background}')`;
                    }
                    card.appendChild(bg);

                    const content = document.createElement('div');
                    content.className = 'player-content';

                    const main = document.createElement('div');
                    main.className = 'player-main';

                    const avatar = document.createElement('img');
                    avatar.className = 'player-avatar';
                    avatar.src = player.avatar;
                    avatar.alt = player.username || 'Player avatar';
                    main.appendChild(avatar);

                    const textBlock = document.createElement('div');
                    textBlock.className = 'player-text';

                    const nameEl = document.createElement('div');
                    nameEl.className = 'player-text-name';
                    nameEl.textContent = player.username;
                    textBlock.appendChild(nameEl);

                    const metaEl = document.createElement('div');
                    metaEl.className = 'player-text-meta';
                    const accValue = player.accuracy != null ? `${player.accuracy}%` : 'N/A';
                    const rankValue = player.rank != null ? `#${player.rank}` : 'Unranked';
                    metaEl.textContent = `ACC: ${accValue} • Rank: ${rankValue}`;
                    textBlock.appendChild(metaEl);

                    main.appendChild(textBlock);

                    const scoreWrapper = document.createElement('div');
                    scoreWrapper.className = 'player-score';

                    const scoreValueEl = document.createElement('div');
                    scoreValueEl.className = 'player-score-value';
                    scoreValueEl.dataset.scoreFor = String(player.id);

                    const score = player.score != null ? player.score : 0;
                    scoreValueEl.textContent = Number(score).toLocaleString();
                    scoreWrapper.appendChild(scoreValueEl);

                    const scoreLabelEl = document.createElement('div');
                    scoreLabelEl.className = 'player-score-label';
                    scoreLabelEl.textContent = 'SCORE';
                    scoreWrapper.appendChild(scoreLabelEl);

                    const statsEl = document.createElement('div');
                    statsEl.className = 'player-score-stats';

                    const pc = Number(player.playcount || 0);
                    const safeScore = Number(player.score || 0);
                    const avg = pc > 0 ? Math.round(safeScore / pc) : 0;

                    // Plays: <span>[number]</span>
                    const playcountEl = document.createElement('div');
                    playcountEl.className = 'player-score-stat';

                    const playcountLabel = document.createElement('span');
                    playcountLabel.className = 'player-score-stat-label';
                    playcountLabel.textContent = 'Plays: ';

                    const playcountValue = document.createElement('span');
                    playcountValue.className = 'player-score-stat-value';
                    playcountValue.dataset.playcountFor = String(player.id);
                    playcountValue.textContent = pc.toLocaleString();

                    playcountEl.appendChild(playcountLabel);
                    playcountEl.appendChild(playcountValue);
                    statsEl.appendChild(playcountEl);

                    // Avg: <span>[number]</span>
                    const avgEl = document.createElement('div');
                    avgEl.className = 'player-score-stat';

                    const avgLabel = document.createElement('span');
                    avgLabel.className = 'player-score-stat-label';
                    avgLabel.textContent = 'Avg: ';

                    const avgValue = document.createElement('span');
                    avgValue.className = 'player-score-stat-value';
                    avgValue.dataset.avgFor = String(player.id);
                    avgValue.textContent = avg.toLocaleString();

                    avgEl.appendChild(avgLabel);
                    avgEl.appendChild(avgValue);
                    statsEl.appendChild(avgEl);

                    scoreWrapper.appendChild(statsEl);

                    if (String(player.id) === String(currentOsuId) && !matchEnded) {
                        const refreshBtn = document.createElement('button');
                        refreshBtn.className = 'player-refresh-button';
                        refreshBtn.textContent = 'Refresh';
                        refreshBtn.onclick = () => refreshPlayer(player, refreshBtn);
                        scoreWrapper.appendChild(refreshBtn);
                    }

                    content.appendChild(main);
                    content.appendChild(scoreWrapper);
                    card.appendChild(content);

                    row.appendChild(rankText);
                    row.appendChild(card);

                    return row;
                }

                function buildTeams(playersArr) {
                    const teams = new Map();

                    for (const p of playersArr) {
                        const teamName = p.team || 'No Team';
                        if (!teams.has(teamName)) {
                            teams.set(teamName, { name: teamName, players: [], totalScore: 0 });
                        }
                        const team = teams.get(teamName);
                        team.players.push(p);
                        team.totalScore += p.score || 0;
                    }

                    return Array.from(teams.values()).sort(
                        (a, b) => b.totalScore - a.totalScore
                    );
                }

                function renderTeamsOverview(teams) {
                    const container = document.getElementById('teams-overview');
                    container.innerHTML = '';

                    const heading = document.createElement('h2');
                    heading.textContent = 'Teams Overview';
                    container.appendChild(heading);

                    teams.forEach(team => {
                        const card = document.createElement('div');
                        card.className = 'team-card';

                        const header = document.createElement('div');
                        header.className = 'team-card-header';

                        const nameEl = document.createElement('div');
                        nameEl.className = 'team-name';
                        nameEl.textContent = team.name;
                        header.appendChild(nameEl);

                        const scoreEl = document.createElement('div');
                        scoreEl.className = 'team-score';
                        scoreEl.textContent = Number(team.totalScore).toLocaleString();
                        header.appendChild(scoreEl);

                        card.appendChild(header);

                        const list = document.createElement('ul');
                        list.className = 'team-player-list';

                        team.players
                            .slice()
                            .sort((a, b) => b.score - a.score)
                            .forEach(p => {
                                const li = document.createElement('li');
                                li.textContent = `${p.username} (${Number(p.score || 0).toLocaleString()})`;
                                list.appendChild(li);
                            });

                        card.appendChild(list);
                        container.appendChild(card);
                    });
                }

                function renderAll() {
                    console.log("[render] renderAll() start");
                    const matchInfo = document.getElementById('match-info');
                    matchInfo.innerHTML = "";

                    const sortedPlayers = [...players].sort((a, b) => (b.score || 0) - (a.score || 0));
                    sortedPlayers.forEach((player, index) => {
                        const row = createPlayerRow(player, index);
                        matchInfo.appendChild(row);
                    });

                    const teams = buildTeams(sortedPlayers);
                    renderTeamsOverview(teams);
                    console.log("[render] renderAll() done", {
                        renderedPlayers: sortedPlayers.length,
                        teams: teams.length
                    });
                }

                // changeMap: Map(userId -> { scoreFrom, scoreTo, playFrom, playTo, avgFrom, avgTo })
                function renderAllAnimated(changeMap) {
                    console.log("[render] renderAllAnimated() called", {
                        hasChangeMap: Boolean(changeMap),
                        changeKeys: changeMap ? Array.from(changeMap.keys()) : []
                    });

                    const prevRects = captureRowPositions();
                    renderAll();
                    renderTeamsOverview(teams);
                    animateRowReorder(prevRects);

                    if (!changeMap) return;

                    for (const [userId, c] of changeMap.entries()) {
                        const scoreEl = document.querySelector(
                            `.player-score-value[data-score-for="${CSS.escape(String(userId))}"]`
                        );
                        const playEl = document.querySelector(
                            `.player-score-stat-value[data-playcount-for="${CSS.escape(String(userId))}"]`
                        );
                        const avgEl = document.querySelector(
                            `.player-score-stat-value[data-avg-for="${CSS.escape(String(userId))}"]`
                        );

                        console.log("[render] elements found?", {
                            userId,
                            scoreEl: Boolean(scoreEl),
                            playEl: Boolean(playEl),
                            avgEl: Boolean(avgEl)
                        });

                        if (scoreEl) {
                            const diff = Number(c.scoreTo) - Number(c.scoreFrom);
                            if (diff !== 0) bumpScore(scoreEl, diff);
                            animateNumber(scoreEl, c.scoreFrom, c.scoreTo, 650);
                        }
                        if (playEl) animateNumber(playEl, c.playFrom, c.playTo, 650);
                        if (avgEl) animateNumber(avgEl, c.avgFrom, c.avgTo, 650);
                    }
                }

                document.addEventListener('DOMContentLoaded', () => {
                    console.log("[match] DOMContentLoaded");

                    const loading = document.getElementById('loading-indicator');
                    if (loading) loading.remove();

                    renderAll();

                    console.log("[socket] initializing socket.io");
                    const socket = io({
                        transports: ["websocket", "polling"],
                    });

                    socket.on("connect", () => {
                        console.log("[socket] connected", {
                            id: socket.id,
                            transport: socket.io.engine?.transport?.name
                        });
                        console.log("[socket] joining match room", { matchId: String(matchId) });
                        socket.emit("join_match", { match_id: String(matchId) });
                    });

                    socket.on("disconnect", (reason) => {
                        console.warn("[socket] disconnected", { reason });
                    });

                    socket.on("connect_error", (err) => {
                        console.error("[socket] connect_error", err);
                    });

                    socket.onAny((eventName, ...args) => {
                        if (eventName !== "match_user_score_updated") return;
                        console.log("[socket] event received:", eventName, args?.[0]);
                    });

                    socket.on("match_user_score_updated", (payload) => {
                        if (!payload) return;
                        if (String(payload.match.match) !== String(matchId)) return;

                        const userId = String(payload.player?.id);
                        const newScoreAbs = Number(payload.player?.score);
                        const newPlayAbs = Number(payload.player?.playcount);

                        const p = players.find(x => String(x.id) === userId);
                        if (!p) return;

                        console.log("[socket] match_user_score_updated - current player state:", {
                            userId,
                            matchEnded,
                            payload: payload,
                            currentPlayer: {
                                score: p.score,
                                playcount: p.playcount,
                                starting_score: p.starting_score,
                                starting_playcount: p.starting_playcount,
                                ending_score: p.ending_score,
                                ending_playcount: p.ending_playcount
                            }
                        });

                        const oldScoreRel = Number(p.score || 0);
                        const oldPlayRel = Number(p.playcount || 0);
                        const oldAvg = oldPlayRel > 0 ? Math.round(oldScoreRel / oldPlayRel) : 0;

                        const startingScore = Number(payload.match.starting_score || 0);
                        const startingPlaycount = Number(payload.match.starting_playcount || 0);

                        const endingScore = Number(payload.match.ending_score || 0);
                        const endingPlaycount = Number(payload.match.ending_playcount || 0);

                        // IMPORTANT: your requested rule
                        // - not ended: current - starting
                        // - ended:     starting - ending (ending is what we receive in payload in this case)
                        const newScoreRel = matchEnded
                            ? (startingScore - endingScore)
                            : (newScoreAbs - startingScore);

                        const newPlayRel = matchEnded
                            ? (startingPlaycount - endingPlaycount)
                            : (newPlayAbs - startingPlaycount);

                        const newAvg = newPlayRel > 0 ? Math.round(newScoreRel / newPlayRel) : 0;

                        // keep local state in sync (these are match-relative)
                        p.score = newScoreRel;
                        p.playcount = newPlayRel;

                        const changeMap = new Map();
                        changeMap.set(userId, {
                            scoreFrom: oldScoreRel,
                            scoreTo: newScoreRel,
                            playFrom: oldPlayRel,
                            playTo: newPlayRel,
                            avgFrom: oldAvg,
                            avgTo: newAvg,
                        });

                        renderAllAnimated(changeMap);
                    });
                });
            </script>
        {% endblock %}
    </body>
</html>